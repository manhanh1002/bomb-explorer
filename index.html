<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bomb Explorer - Solo & Multi Bomb Game Prototype</title>
    <style>
        @keyframes shake {
    0% { transform: translate(1px, 1px) rotate(0deg); }
    10% { transform: translate(-1px, -2px) rotate(-1deg); }
    30% { transform: translate(3px, 2px) rotate(0deg); }
    50% { transform: translate(-1px, 2px) rotate(1deg); }
    70% { transform: translate(3px, 1px) rotate(-1deg); }
    100% { transform: translate(1px, -2px) rotate(0deg); }
        }

        .shake-effect {
        animation: shake 0.5s;
        animation-iteration-count: 1;
         }
         .modal-lost-style {
    background-color: #2a0000 !important;
    color: #ff0000 !important;
    border: 3px solid #ff0000 !important;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    position: relative;
}

/* Hi·ªáu ·ª©ng nh·∫•p nh√°y ƒë·ªè khi thua */
@keyframes red-flash {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}
.modal-lost-style h2 {
    animation: red-flash 0.2s infinite;
}
/* Hi·ªáu ·ª©ng tia qu√©t Radar */
@keyframes radar-scan {
    0% { top: -5%; opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { top: 105%; opacity: 0; }
}

/* Container ch·ª©a l∆∞·ªõi game khi ·ªü ch·∫ø ƒë·ªô Detector */
.grid-container.detector-active {
    position: relative;
    overflow: hidden; /* ƒê·ªÉ tia qu√©t kh√¥ng bay ra ngo√†i b·∫£ng */
    border: 2px solid var(--success-ink); /* ƒê·ªïi vi·ªÅn b·∫£ng sang xanh khi d√≤ */
    transition: border 0.3s ease;
}

/* C·∫•u tr√∫c c·ªßa tia qu√©t */
.grid-container.detector-active::after {
    content: "";
    position: absolute;
    left: 0;
    width: 100%;
    height: 15px; /* ƒê·ªô d√†y c·ªßa tia s√°ng */
    background: linear-gradient(to bottom, 
        transparent, 
        rgba(0, 255, 0, 0.4), 
        transparent);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.6);
    z-index: 10;
    pointer-events: none; /* Quan tr·ªçng: ƒë·ªÉ kh√¥ng ngƒÉn c·∫£n vi·ªác click v√†o √¥ */
    animation: radar-scan 2s linear infinite;
}
        :root {
            --paper-light: #e8e3d7;   /* Old paper */
            --paper-dark:  #cfc8b8;   /* Aged paper */
            --ink-black:   #1b1b1b;   /* Printed ink */
            --charcoal:    #2a2a2a;   /* Dark charcoal */
            --olive-muted: #5b5f4a;   /* Military green */
            --mud-brown:   #6a5b4d;   /* Mud brown */
            --rust-dark:   #7a4b3a;   /* Rusted metal */
            --danger-ink:  #7b2d2d;   /* Stamped red */
            --success-ink: #3f5f3f;   /* Stamped green */
            --neutral-ink: #444444;   /* Standard ink */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Courier New", Courier, monospace;
            background-color: #1f1f1f;
            background-image: 
                radial-gradient(circle at 30% 30%, #3a3a3a 0%, #1f1f1f 70%),
                repeating-linear-gradient(
                    45deg,
                    rgba(255,255,255,0.02),
                    rgba(255,255,255,0.02) 2px,
                    transparent 2px,
                    transparent 6px
                );
            color: var(--paper-light);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 25px;
            color: var(--paper-light);
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 0px #000;
            font-weight: 900;
            border-bottom: 2px solid var(--paper-dark);
            padding-bottom: 10px;
        }

        /* --- PANELS (Paper / Clipboard Style) --- */
        .setup-screen, 
        .board-section, 
        .controls-section, 
        .info-section, 
        .log-section, 
        .mission-card, 
        .modal-content {
            background-color: var(--paper-light);
            color: var(--ink-black);
            border: 2px solid var(--charcoal);
            border-radius: 2px;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4), 
                inset 0 1px 0 rgba(255,255,255,0.3);
            /* Paper Texture */
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    rgba(0,0,0,0.02),
                    rgba(0,0,0,0.02) 1px,
                    transparent 1px,
                    transparent 3px
                );
            padding: 20px;
            margin-bottom: 20px;
        }

        .setup-screen {
            max-width: 500px;
            margin: 0 auto;
            transform: rotate(-0.5deg); /* Slight natural rotation */
        }

        .setup-section {
            margin-bottom: 25px;
            border-bottom: 1px dashed var(--charcoal);
            padding-bottom: 15px;
        }
        .setup-section:last-child {
            border-bottom: none;
        }

        .setup-label, .log-title, .mission-title, .info-label, .game-section-title {
            color: var(--charcoal);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 18px;
            letter-spacing: 1px;
            margin-bottom: 10px;
            display: block;
        }

        /* --- BUTTONS (Mechanical / Tactile) --- */
        button, .mode-btn, .event-btn, .start-btn, .how-to-play-btn, .modal-close-btn {
            font-family: "Courier New", Courier, monospace;
            background: linear-gradient(#d8d2c4, #bfb8a8);
            color: var(--ink-black);
            border: 2px solid var(--charcoal);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.3), 
                0 2px 2px rgba(0,0,0,0.4);
            padding: 12px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 2px;
            transition: all 0.1s;
            font-size: 12px;
        }

        button:hover, .mode-btn:hover, .event-btn:hover {
            transform: translateY(1px);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.15), 
                0 1px 1px rgba(0,0,0,0.4);
            filter: brightness(0.95);
        }

        /* Active / Selected State */
        button:active, 
        .mode-btn.active, 
        .event-btn.active, 
        .btn-detector.active
        {
            background: var(--charcoal);
            color: var(--paper-light);
            border-color: #000;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
            transform: translateY(2px);
        }
        .lang-btn.active {
            background: var(--charcoal);
            color: var(--paper-light);
            border-color: #000;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
            transform: translateY(2px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: grab;
            filter: grayscale(1);
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .mode-btn { flex: 1; }

        .start-btn {
            width: 100%;
            background: linear-gradient(var(--olive-muted), #4a4e3b);
            color: var(--paper-light);
            font-size: 16px;
            letter-spacing: 2px;
            border-color: #2b3020;
        }
        .start-btn:hover {
            filter: brightness(1.1);
            color: #fff;
        }

        .btn-detector {
            background: linear-gradient(#5b7c8f, #4a6575);
            color: var(--paper-light);
        }
        .btn-restart {
            background: linear-gradient(var(--danger-ink), #5a1e1e);
            color: var(--paper-light);
        }

        .how-to-play-btn {
            display: block;
            margin: 0 auto 20px;
            background: var(--paper-dark);
            width: auto;
        }

        /* --- INPUTS --- */
        .bomb-count-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .bomb-count-selector input {
            width: 80px;
            padding: 8px;
            background-color: var(--paper-light);
            border: 2px solid var(--charcoal);
            color: var(--ink-black);
            font-family: inherit;
            font-weight: bold;
            text-align: center;
            font-size: 16px;
        }
        .hint-text {
            font-size: 11px;
            color: var(--olive-muted);
            font-style: italic;
        }

        /* --- EVENTS GRID --- */
        .events-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .event-btn {
            text-align: left;
            position: relative;
        }
        .event-btn:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--charcoal);
            color: var(--paper-light);
            padding: 8px 12px;
            border: 1px solid var(--paper-light);
            white-space: nowrap;
            font-size: 11px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }
        .event-difficulty {
            font-size: 10px;
            color: var(--danger-ink);
            margin-top: 4px;
            font-weight: bold;
        }

        /* --- GAME LAYOUT --- */
        .game-screen { display: none; }
        .game-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* --- BOARD & TILES --- */
        .board {
            display: grid;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            border: 2px dashed rgba(255,255,255,0.05);
        }

        .tile {
            width: 80px;
            height: 80px;
            border: 2px solid #1a1a1a;
            border-radius: 3px;
            background-color: #2d2d2d;
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            transition: transform 0.1s;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 2px #000;
        }

        .tile:hover:not(.tile-disabled):not(.tile-flipped) {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.6);
            border-color: var(--paper-light);
            filter: brightness(1.1);
        }

        .tile-unflipped {
            background-image: url('Assets/tiles/tile-unflip.png');
        }

        /* Tile Backgrounds */
        .tile-bg-bomb { background-image: url('Assets/tiles/tile-bomb.png'); }
        .tile-bg-defuse { background-image: url('Assets/tiles/tile-defuse-kit.png'); }
        .tile-bg-repair { background-image: url('Assets/tiles/tile-detector-repair.png'); }
        .tile-bg-shuffle { background-image: url('Assets/tiles/tile-suffle.png'); }
        .tile-bg-adrenaline { background-image: url('Assets/tiles/tile-adrenaline.png'); }
        .tile-bg-empty { background-image: url('Assets/tiles/tile-empty.png'); }

        .tile-flipped {
            cursor: default;
            border-color: #555;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .tile-disabled {
            cursor: grab;
            filter: grayscale(0.8) opacity(0.8);
        }
        
        .detector-mode-active {
            box-shadow: 0 0 0 3px var(--paper-light), 0 0 15px var(--paper-light);
            z-index: 10;
        }

        /* --- INFO & LOGS --- */
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px dashed var(--charcoal);
        }
        .info-row:last-child { border-bottom: none; }
        
        .info-label { margin-bottom: 0; font-size: 12px; }
        .info-value {
            color: var(--danger-ink);
            font-weight: bold;
            font-size: 14px;
        }

        .mission-desc {
            font-size: 13px;
            line-height: 1.5;
            color: var(--ink-black);
            font-style: italic;
        }

        .log-content {
            background-color: #f4f1ea;
            border: 1px solid var(--charcoal);
            padding: 10px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 11px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 4px 8px;
            border-left: 3px solid var(--charcoal);
            background: rgba(0,0,0,0.03);
            font-family: "Courier New", monospace;
        }
        .log-entry.success { border-left-color: var(--success-ink); color: var(--success-ink); }
        .log-entry.danger { border-left-color: var(--danger-ink); color: var(--danger-ink); }
        .log-entry.info { border-left-color: var(--neutral-ink); color: var(--ink-black); }
        .log-entry.warning { border-left-color: var(--mud-brown); color: var(--mud-brown); }

        /* --- STATUS MESSAGES --- */
        .status-message {
            padding: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            margin-top: 20px;
            border: 3px solid var(--charcoal);
            text-transform: uppercase;
            letter-spacing: 1px;
            background: var(--paper-light);
            color: var(--ink-black);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .status-win {
            border-color: var(--success-ink);
            color: var(--success-ink);
            background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(63,95,63,0.1) 10px, rgba(63,95,63,0.1) 20px);
        }
        .status-lose {
            border-color: var(--danger-ink);
            color: var(--danger-ink);
            background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(123,45,45,0.1) 10px, rgba(123,45,45,0.1) 20px);
        }

        /* --- CONTROLS --- */
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 0;
        }

        /* --- LANGUAGE SWITCH --- */
        .language-switch {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 15px;
        }
        .lang-btn {
            background: transparent;
            border: 1px solid var(--paper-dark);
            color: var(--olive-muted);
            border-radius: 2px;
        }
        .lang-btn.active {
            background: var(--paper-light);
            color: var(--ink-black);
            border-color: var(--paper-light);
        }

        /* --- MODAL --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(3px);
        }
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content h2 {
            color: var(--danger-ink);
            border-bottom: 2px solid var(--charcoal);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .modal-content h3 {
            color: var(--olive-muted);
            margin-top: 15px;
            text-transform: uppercase;
        }
        .modal-content p, .modal-content li {
            font-size: 13px;
            color: var(--ink-black);
        }

        @media (max-width: 768px) {
            .game-wrapper { grid-template-columns: 1fr; }
            .events-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß® Bomb Explorer</h1>
        
        <!-- SETUP SCREEN -->
        <div class="setup-screen" id="setupScreen">
            <button class="how-to-play-btn" id="howToPlayBtn">? HOW TO PLAY</button>
            <div class="setup-section">
                <div class="setup-label">Select Game Mode</div>
                <div class="mode-buttons">
                    <button class="mode-btn active" data-mode="solo">Solo (1 Bomb)</button>
                    <button class="mode-btn" data-mode="multi">Multi Bomb</button>
                </div>
            </div>

            <div class="setup-section" id="multiBombSetup" style="display: none;">
                <div class="setup-label">Number of Bombs</div>
                <div class="bomb-count-selector">
                    <input type="number" id="bombCount" min="2" max="10" value="2">
                    <span class="hint-text">Total tiles will be calculated automatically</span>
                </div>
            </div>

            <div class="setup-section">
                <div class="setup-label">Select Event</div>
                <div class="events-grid" id="eventsGrid"></div>
            </div>

            <button class="start-btn" id="startBtn">START GAME</button>
            
            <div class="language-switch">
                <button class="lang-btn active" data-lang="EN">English</button>
                <button class="lang-btn" data-lang="VI">Ti·∫øng Vi·ªát</button>
            </div>
        </div>
        <!-- result modal-->
<div class="modal" id="gameOverModal">
    <div class="modal-content" style="text-align: center; max-width: 400px;">
        <h2 id="gameOverTitle">GAME ENDED</h2>
        <p id="gameOverMessage" style="font-size: 16px; margin: 20px 0; font-weight: bold;">...</p>
        
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 25px;">
            <button class="start-btn" id="modalRestartBtn" style="width: auto; padding: 10px 20px;">üîÑ REPLAY</button>
            <button class="modal-close-btn" id="modalMenuBtn" style="width: auto;">BACK TO MENU</button>
        </div>
    </div>
</div>
        <!-- HOW TO PLAY MODAL -->
        <div class="modal" id="howToPlayModal">
            <div class="modal-content">
                <h2 id="modalTitle">üìñ HOW TO PLAY</h2>
                <div id="modalBody">
                    <h3> OBJECTIVE</h3>
                    <p>Defuse all bombs on the board by collecting 2 Defuse Kits per bomb, then flip the bomb tile to win.</p>
                    
                    <h3>GAME MODES</h3>
                    <ul>
                        <li><strong>Solo (1 Bomb):</strong> Classic 3√ó3 grid with 1 bomb to defuse</li>
                        <li><strong>Multi Bomb:</strong> Larger board with X bombs (2-10)</li>
                    </ul>

                    <h3> TILE TYPES</h3>
                    <ul>
                        <li><strong> Bomb:</strong> Flip with 2+ Defuse Kits to defuse. Without kits = LOSE</li>
                        <li><strong> Defuse Kit:</strong> Collect 2 per bomb defusal</li>
                        <li><strong> Detector Repair:</strong> Restore 1 used Mine Detector</li>
                        <li><strong> Shuffle:</strong> Randomize all face-down tiles</li>
                        <li><strong>Adrenaline:</strong> Choose 1 face-down tile to flip (no turn cost, Detector disabled)</li>
                        <li><strong> Empty:</strong> Nothing happens</li>
                    </ul>

                    <h3> MINE DETECTORS</h3>
                    <ul>
                        <li>Reveal tile content without flipping</li>
                        <li>One-time use per tile</li>
                        <li>Can be restored by Detector Repair or Emergency Repair event</li>
                        <li>Start with 2 (Solo) or bombCount√ó2 (Multi)</li>
                    </ul>

                    <h3> LOSE CONDITIONS</h3>
                    <ul>
                        <li>Flip Bomb without 2+ Defuse Kits</li>
                        <li>Remaining unflipped tiles = remaining bombs (Dead-end state)</li>
                        <li>Sudden Rain event triggers twice (if enabled)</li>
                    </ul>

                    <h3>SPECIAL EVENTS (6 TYPES)</h3>
                    <ul>
                        <li><strong>Classic Event:</strong> No special rules</li>
                        <li><strong>Bonus From Boss:</strong> Start with 3 detectors</li>
                        <li><strong>Lucky Find:</strong> Start with 1 extra Defuse Kit</li>
                        <li><strong>Sudden Rain:</strong> First bomb without kit = eliminate (continue). Second = LOSE</li>
                        <li><strong>The Calm Team:</strong> Use detector during Adrenaline flip</li>
                        <li><strong>A Good Place:</strong> Only 1 Shuffle tile (has no effect)</li>
                    </ul>

                    <h3> WINNING</h3>
                    <p>Collect enough Defuse Kits, then flip all bomb tiles. When all bombs are defused, you WIN!</p>
                </div>
                <button class="modal-close-btn" id="closeModalBtn">CLOSE</button>
            </div>
        </div>

        <!-- GAME SCREEN -->
        <div class="game-screen" id="gameScreen">
            <div class="game-wrapper">
                <div class="left-panel">
                    <div class="board-section">
                        <h3 class="game-section-title" style="margin-bottom: 15px; color: var(--charcoal);">Board</h3>
                        <div class="board" id="board"></div>
                    </div>

                    <div class="controls-section">
                        <div class="button-group">
                            <button class="btn-detector" id="btnDetector">Use Detector</button>
                            <button class="btn-restart" id="btnRestart">Back to Setup</button>
                        </div>
                        <div style="color: var(--olive-muted); font-size: 12px; margin-top: 10px;" id="detectorInfo">Mine Detector mode: OFF</div>
                    </div>
                </div>

                <div class="right-panel">
                    <div class="info-section">
                        <div class="info-row">
                            <span class="info-label">Game Mode:</span>
                            <span class="info-value" id="gameMode">Solo</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Bombs Remaining:</span>
                            <span class="info-value" id="bombsRemaining">1</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Defuse Kits Available:</span>
                            <span class="info-value" id="defuseKitsAvailable">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Mine Detectors:</span>
                            <span class="info-value" id="detectorsAvailable">2</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Game Status:</span>
                            <span class="info-value" id="gameStatus">PLAYING</span>
                        </div>
                    </div>

                    <div class="mission-card">
                        <div class="mission-title" id="eventTitle">Event</div>
                        <div class="mission-desc" id="eventDesc">Loading...</div>
                    </div>

                    <div class="log-section">
                        <div class="log-title">Game Log</div>
                        <div class="log-content" id="logContent"></div>
                    </div>
                </div>
            </div>

            <div id="statusMessage"></div>
        </div>
    </div>

    <script>
        // ƒêƒÉng k√Ω Service Worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // S·ª≠ d·ª•ng './sw.js' thay v√¨ '/sw.js' ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi GitHub Pages
        navigator.serviceWorker.register('./sw.js')
            .then(reg => console.log('SW registered!', reg))
            .catch(err => console.log('SW registration failed:', err));
    });
}
        // ========================================
        // CONSTANTS & TRANSLATIONS
        // ========================================
        let currentLanguage = 'EN';

        const TILE_TYPES = {
            BOMB: 'BOMB',
            DEFUSE_KIT: 'DEFUSE_KIT',
            DETECTOR_REPAIR: 'DETECTOR_REPAIR',
            EFFECT_SHUFFLE: 'EFFECT_SHUFFLE',
            EFFECT_ADRENALINE: 'EFFECT_ADRENALINE',
            EMPTY: 'EMPTY'
        };

        const TRANSLATIONS = {
            EN: {
                ui: {
                    title: "üß® Bomb Explorer",
                    howToPlay: "? HOW TO PLAY",
                    selectMode: "Select Game Mode",
                    solo: "Solo (1 Bomb)",
                    multi: "Multi Bomb",
                    numBombs: "Number of Bombs",
                    autoCalc: "Total tiles will be calculated automatically",
                    selectEvent: "Select Event",
                    start: "START GAME",
                    board: "Board",
                    useDetector: "Use Detector",
                    backToSetup: "Back to Setup",
                    detectorOff: "Mine Detector mode: OFF",
                    detectorOn: " Mine Detector mode: ON",
                    adrenalineMode: "ADRENALINE MODE: Select a tile to flip (Detector disabled)",
                    gameMode: "Game Mode:",
                    bombsRemaining: "Bombs Remaining:",
                    defuseKits: "Defuse Kits Available:",
                    detectors: "Mine Detectors:",
                    status: "Game Status:",
                    playing: "PLAYING",
                    won: "WON ",
                    lost: "LOST ",
                    eventTitle: "Event",
                    logTitle: "Game Log",
                    winMsg: " YOU WIN! All bombs defused!",
                    loseMsg: " You lost.",
                    modalTitle: "HOW TO PLAY",
                    gameOverTitleWin: "VICTORY",
                    gameOverTitleLose: "GAME OVER",
                    btnReplay: "Play Again",
                    btnMenu: "Back to Menu",
                    modalContent: `
                     <h3> STORY</h3>
                        <p>The player takes on the role of a bomb removal soldier, dispatched to a derelict area to locate and defuse every mine before the main squad moves in.</p>
                    <h3> OBJECTIVE</h3>
                        <p>Defuse all bombs on the board by collecting 2 Defuse Kits per bomb, then flip the bomb tile to win.</p>
                        <h3>GAME MODES</h3>
                        <ul>
                            <li><strong>Solo (1 Bomb):</strong> Classic 3√ó3 grid with 1 bomb to defuse</li>
                            <li><strong>Multi Bomb:</strong> Larger board with X bombs (2-10)</li>
                        </ul>
                        <h3> TILE TYPES</h3>
                        <ul>
                            <li><strong> Bomb:</strong> Flip with 2+ Defuse Kits to defuse. Without kits = LOSE</li>
                            <li><strong> Defuse Kit:</strong> Collect 2 per bomb defusal</li>
                            <li><strong> Detector Repair:</strong> Restore 1 used Mine Detector</li>
                            <li><strong> Shuffle:</strong> Randomize all face-down tiles</li>
                            <li><strong>Adrenaline:</strong> Choose 1 face-down tile to flip (no turn cost, Detector disabled)</li>
                            <li><strong> Empty:</strong> Nothing happens</li>
                        </ul>
                        <h3> MINE DETECTORS</h3>
                        <ul>
                            <li>Reveal tile content without flipping</li>
                            <li>One-time use per tile</li>
                            <li>Can be restored by Detector Repair or Emergency Repair event</li>
                            <li>Start with 2 (Solo) or bombCount√ó2 (Multi)</li>
                        </ul>
                        <h3> LOSE CONDITIONS</h3>
                        <ul>
                            <li>Flip Bomb without 2+ Defuse Kits</li>
                            <li>Remaining unflipped tiles = remaining bombs (Dead-end state)</li>
                            <li>Sudden Rain event triggers twice (if enabled)</li>
                        </ul>
                        <h3>SPECIAL EVENTS (6 TYPES)</h3>
                        <ul>
                            <li><strong>Classic Event:</strong> No special rules</li>
                            <li><strong>Bonus From Boss:</strong> One extra Mine Detector at the start.</li>
                            <li><strong>Lucky Find:</strong> Start with 1 extra Defuse Kit</li>
                            <li><strong>Sudden Rain:</strong> First bomb without kit = eliminate (continue). Second = LOSE</li>
                            <li><strong>The Calm Team:</strong> Use detector during Adrenaline flip</li>
                            <li><strong>A Good Place:</strong> Only 1 Shuffle tile (has no effect)</li>
                        </ul>
                        <h3> WINNING</h3>
                        <p>Collect enough Defuse Kits, then flip all bomb tiles. When all bombs are defused, you WIN!</p>
                    `
                },
                logs: {
                    detectorUsed: "Mine Detector used: Revealed {tile}",
                    bombDefused: " BOMB DEFUSED! Bombs remaining: {count}",
                    allDefused: "ALL BOMBS DEFUSED! YOU WIN!",
                    bombDetectedNeedKits: "‚ö†Ô∏è BOMB DETECTED: Need 2 Defuse Kits to defuse. Tile remains face-down.",
                    tileFlipped: " Tile flipped: {tile}",
                    suddenRainElim: " SUDDEN RAIN: Player eliminated. Bomb removed. Game continues.",
                    gameOverBomb: " Bomb flipped without enough Defuse Kits.",
                    defuseKitCollected: " Defuse Kit collected! ({count} available)",
                    detectorRestored: " Detector Repair: Restored 1 detector (now have {count} available).",
                    detectorNoRepair: " Detector Repair: No used detectors to restore.",
                    shuffleNegated: " SHUFFLE triggered but A GOOD PLACE event negates it. Treated as Empty.",
                    shuffleTriggered: " SHUFFLE: All face-down tiles have been reshuffled.",
                    adrenalineTriggered: "ADRENALINE: Random face-down tile will flip automatically (no turn consumed).",
                    emptyTile: " Empty tile.",
                    autoFlip: "Auto-flipping index {index}...",
                    adrenalineFlipResult: "Adrenaline flip result: {tile}",
                    bombDefusedAdrenaline: " BOMB DEFUSED (adrenaline)! Bombs remaining: {count}",
                    gameOverAdrenaline: "  Bomb hit during adrenaline flip without kits.",
                    adrenalineAgain: "ADRENALINE triggered again! Choose next tile to flip.",
                    autoFlipResult: "Auto-flip result: {tile}",
                    bombDefusedAuto: " BOMB DEFUSED (auto-flip)! Bombs remaining: {count}",
                    gameOverAuto: "  Bomb hit during auto-flip without kits.",
                    adrenalineChoice: "ADRENALINE: Choose 1 tile to flip (Detector unavailable)",
                    adrenalineDetector: "ADRENALINE (via detector): Choose next tile to flip. Detector available (CALM TEAM).",
                    adrenalineDetectorNo: "ADRENALINE (via detector): Choose next tile to flip (Detector unavailable).",
                    deadEnd: " Dead-end detected: {bombs} Bomb time counted to Zero and auto explode!As remaining tiles equals remaining bombs!",
                    gameIsOver: "Game is over",
                    tileAlreadyFlipped: "Tile already flipped",
                    tileAlreadyDetected: "Tile already detected",
                    noDetectors: "No detectors available",
                    actionFailed: "Action failed"
                },
                tiles: {
                    [TILE_TYPES.BOMB]: ' Bomb',
                    [TILE_TYPES.DEFUSE_KIT]: ' Defuse Kit',
                    [TILE_TYPES.DETECTOR_REPAIR]: ' Detector Repair',
                    [TILE_TYPES.EFFECT_SHUFFLE]: ' Shuffle',
                    [TILE_TYPES.EFFECT_ADRENALINE]: 'Adrenaline',
                    [TILE_TYPES.EMPTY]: ' Empty'
                }
            },
            VI: {
                ui: {
                    title: "üß® L√≠nh G·ª° M√¨n",
                    howToPlay: "? H∆Ø·ªöNG D·∫™N",
                    selectMode: "Ch·ªçn Ch·∫ø ƒê·ªô",
                    solo: "ƒê∆°n (1 Bom)",
                    multi: "Nhi·ªÅu Bom",
                    numBombs: "S·ªë L∆∞·ª£ng Bom",
                    autoCalc: "T·ªïng s·ªë √¥ s·∫Ω ƒë∆∞·ª£c t√≠nh t·ª± ƒë·ªông",
                    selectEvent: "Ch·ªçn S·ª± Ki·ªán",
                    start: "B·∫ÆT ƒê·∫¶U",
                    board: "B√†n C·ªù",
                    useDetector: "D√πng M√°y D√≤",
                    backToSetup: "V·ªÅ Menu",
                    detectorOff: "Ch·∫ø ƒë·ªô D√≤ M√¨n: T·∫ÆT",
                    detectorOn: " Ch·∫ø ƒë·ªô D√≤ M√¨n: B·∫¨T",
                    adrenalineMode: "H∆ØNG PH·∫§N: Ch·ªçn 1 √¥ ƒë·ªÉ l·∫≠t (Kh√¥ng d√πng ƒë∆∞·ª£c M√°y D√≤)",
                    gameMode: "Ch·∫ø ƒê·ªô:",
                    bombsRemaining: "Bom C√≤n L·∫°i:",
                    defuseKits: "B·ªô G·ª° Bom:",
                    detectors: "M√°y D√≤ M√¨n:",
                    status: "Tr·∫°ng Th√°i:",
                    playing: "ƒêANG CH∆†I",
                    won: "TH·∫ÆNG ",
                    lost: "THUA ",
                    eventTitle: "S·ª± Ki·ªán",
                    logTitle: "Nh·∫≠t K√Ω",
                    winMsg: " Ho√†n th√†nh t·ªët nhi·ªám v·ª• g·ª° bomb!",
                    loseMsg: " B√πm! B·∫°n ƒë√£ b·ªã n·ªï tung.",
                    gameOverTitleWin: "CHI·∫æN TH·∫ÆNG",
                    gameOverTitleLose: "TH·∫§T B·∫†I",
                    btnReplay: "Ch∆°i L·∫°i",
                    btnMenu: "V·ªÅ Menu",
                    modalTitle: "H∆Ø·ªöNG D·∫™N CH∆†I",
                    modalContent: `
                        <h3>C√ÇU CHUY·ªÜN</h3>
                        <p> Ng∆∞·ªùi ch∆°i v√†o vai m·ªôt ng∆∞·ªùi l√≠nh c√¥ng binh, ƒë∆∞·ª£c ph√°i ƒë·∫øn khu v·ª±c ƒë√£ b·ªã b·ªè hoang ƒë·ªÉ t√¨m v√† g·ª° to√†n b·ªô m√¨n tr∆∞·ªõc khi trung ƒë·ªôi ch√≠nh ti·∫øn v√†o.</p>
                        <h3>M·ª§C TI√äU</h3>
                        <p>G·ª° t·∫•t c·∫£ bom tr√™n b√†n c·ªù b·∫±ng c√°ch thu th·∫≠p 2 B·ªô G·ª° cho m·ªói qu·∫£ bom, sau ƒë√≥ l·∫≠t √¥ bom ƒë·ªÉ th√°o g·ª°, ti·∫øp t·ª•c thu th·∫≠p B·ªô G·ª° cho bom c√≤n l·∫°i ƒë·ªÉ th·∫Øng.</p>
                        <h3> CH·∫æ ƒê·ªò CH∆†I</h3>
                        <ul>
                            <li><strong>ƒê∆°n (1 Bom):</strong> B√†n c·ªù 3x3 c·ªï ƒëi·ªÉn v·ªõi 1 qu·∫£ bom.</li>
                            <li><strong>Nhi·ªÅu Bom:</strong> B√†n c·ªù l·ªõn h∆°n v·ªõi X qu·∫£ bom (2-10).</li>
                        </ul>
                        <h3>C√ÅC LO·∫†I √î</h3>
                        <ul>
                            <li><strong>Bom:</strong> L·∫≠t v√† g·ª° th√†nh c√¥ng khi c√≥ 2 B·ªô G·ª° M√¨n ƒë·ªÉ g·ª°. Kh√¥ng ƒë·ªß l√† THUA ngay.</li>
                            <li><strong>B·ªô G·ª°:</strong> Thu th·∫≠p 2 c√°i ƒë·ªÉ g·ª° 1 bom.</li>
                            <li><strong>S·ª≠a M√°y D√≤:</strong> H·ªìi ph·ª•c 1 M√°y D√≤ ƒë√£ d√πng.</li>
                            <li><strong>Rung Ch·∫•n:</strong> X√°o tr·ªôn t·∫•t c·∫£ c√°c √¥ ƒëang √∫p.</li>
                            <li><strong>H∆∞ng Ph·∫•n:</strong> Ch·ªçn 1 √¥ √∫p ƒë·ªÉ l·∫≠t (kh√¥ng t·ªën l∆∞·ª£t, kh√¥ng d√πng ƒë∆∞·ª£c M√°y D√≤).</li>
                            <li><strong>Tr·ªëng:</strong> Kh√¥ng c√≥ g√¨ x·∫£y ra.</li>
                        </ul>
                        <h3>M√ÅY D√í M√åN</h3>
                        <ul>
                            <li>Soi n·ªôi dung √¥ m√† kh√¥ng l·∫≠t n√≥.</li>
                            <li>D√πng 1 l·∫ßn cho m·ªói √¥.</li>
                            <li>C√≥ th·ªÉ h·ªìi ph·ª•c b·∫±ng S·ª≠a M√°y D√≤.</li>
                            <li>B·∫Øt ƒë·∫ßu v·ªõi 2 (Ch·∫ø ƒë·ªô ƒê∆°n) ho·∫∑c S·ªë bom x 2 (Ch·∫ø ƒë·ªô Nhi·ªÅu Bom).</li>
                        </ul>
                        <h3>ƒêI·ªÄU KI·ªÜN THUA</h3>
                        <ul>
                            <li>L·∫≠t Bom m√† kh√¥ng ƒë·ªß 2 B·ªô G·ª°.</li>
                            <li>S·ªë √¥ √∫p c√≤n l·∫°i = S·ªë bom c√≤n l·∫°i (Ng√µ C·ª•t).</li>
                            <li>S·ª± ki·ªán M∆∞a B·∫•t Ch·ª£t k√≠ch ho·∫°t 2 l·∫ßn (n·∫øu c√≥).</li>
                        </ul>
                        <h3>S·ª∞ KI·ªÜN ƒê·∫∂C BI·ªÜT (6 LO·∫†I)</h3>
                        <ul>
                            <li><strong>C·ªï ƒêi·ªÉn:</strong> Kh√¥ng c√≥ lu·∫≠t ƒë·∫∑c bi·ªát.</li>
                            <li><strong>Qu√† C·ªßa S·∫øp:</strong> Th√™m 1 M√°y D√≤ M√¨n khi b·∫Øt ƒë·∫ßu.</li>
                            <li><strong>V·∫≠n May:</strong> B·∫Øt ƒë·∫ßu v·ªõi 1 B·ªô G·ª°.</li>
                            <li><strong>M∆∞a B·∫•t Ch·ª£t:</strong> L·∫≠t tr√∫ng bom kh√¥ng c√≥ b·ªô g·ª° l·∫ßn ƒë·∫ßu = b·ªã lo·∫°i (ti·∫øp t·ª•c). L·∫ßn 2 = THUA.</li>
                            <li><strong>Gi·ªØ B√¨nh Tƒ©nh:</strong> ƒê∆∞·ª£c d√πng M√°y D√≤ trong l√∫c H∆∞ng Ph·∫•n.</li>
                            <li><strong>N·ªÅn ƒê·∫•t T·ªët:</strong> Ch·ªâ c√≥ 1 √¥ Rung Ch·∫•n (v√¥ d·ª•ng).</li>
                        </ul>
                        <h3> CHI·∫æN TH·∫ÆNG</h3>
                        <p>Thu th·∫≠p ƒë·ªß B·ªô G·ª°, sau ƒë√≥ l·∫≠t t·∫•t c·∫£ √¥ Bom. Khi s·∫°ch b√≥ng bomb trong khu v·ª±c, b·∫°n TH·∫ÆNG!</p>
                    `
                },
                logs: {
                    detectorUsed: " ƒê√£ d√πng M√°y D√≤: L·ªô di·ªán {tile}",
                    bombDefused: " G·ª† BOM TH√ÄNH C√îNG! C√≤n l·∫°i: {count}",
                    allDefused: " ƒê√É G·ª† H·∫æT BOM!",
                    bombDetectedNeedKits: "  PH√ÅT HI·ªÜN BOM: C·∫ßn 2 B·ªô G·ª° ƒë·ªÉ x·ª≠ l√Ω. √î v·∫´n √∫p.",
                    tileFlipped: " ƒê√£ l·∫≠t: {tile}",
                    suddenRainElim: " M∆ØA B·∫§T CH·ª¢T: Ng∆∞·ªùi ch∆°i b·ªã lo·∫°i. Bom bi·∫øn m·∫•t. Ti·∫øp t·ª•c.",
                    gameOverBomb: " L·∫≠t tr√∫ng Bom m√† kh√¥ng ƒë·ªß B·ªô G·ª°.",
                    defuseKitCollected: " Nh·∫∑t ƒë∆∞·ª£c B·ªô G·ª°! (Hi·ªán c√≥ {count})",
                    detectorRestored: " S·ª≠a M√°y D√≤: H·ªìi ph·ª•c 1 m√°y (Hi·ªán c√≥ {count}).",
                    detectorNoRepair: " S·ª≠a M√°y D√≤: Kh√¥ng c√≥ m√°y n√†o h·ªèng ƒë·ªÉ s·ª≠a.",
                    shuffleNegated: " Rung Ch·∫•n k√≠ch ho·∫°t nh∆∞ng s·ª± ki·ªán N·ªÅn ƒê·∫•t T·ªët v√¥ hi·ªáu h√≥a n√≥.",
                    shuffleTriggered: " Rung Ch·∫•n: T·∫•t c·∫£ c√°c √¥ √∫p ƒë√£ b·ªã x√°o tr·ªôn.",
                    adrenalineTriggered: "H∆ØNG PH·∫§N: M·ªôt √¥ ng·∫´u nhi√™n s·∫Ω t·ª± l·∫≠t (kh√¥ng t·ªën l∆∞·ª£t).",
                    emptyTile: " √î tr·ªëng.",
                    autoFlip: "ƒêang t·ª± l·∫≠t √¥ s·ªë {index}...",
                    adrenalineFlipResult: "K·∫øt qu·∫£ H∆∞ng Ph·∫•n: {tile}",
                    bombDefusedAdrenaline: " G·ª† BOM (H∆∞ng Ph·∫•n)! C√≤n l·∫°i: {count}",
                    gameOverAdrenaline: " THUA CU·ªòC: N·ªï bom trong l√∫c H∆∞ng Ph·∫•n (thi·∫øu B·ªô G·ª°).",
                    adrenalineAgain: "H∆ØNG PH·∫§N k√≠ch ho·∫°t ti·∫øp! Ch·ªçn √¥ ti·∫øp theo ƒë·ªÉ l·∫≠t.",
                    autoFlipResult: "K·∫øt qu·∫£ t·ª± l·∫≠t: {tile}",
                    bombDefusedAuto: " G·ª† BOM (t·ª± l·∫≠t)! C√≤n l·∫°i: {count}",
                    gameOverAuto: " N·ªï bom trong l√∫c t·ª± l·∫≠t (thi·∫øu B·ªô G·ª°).",
                    adrenalineChoice: "H∆ØNG PH·∫§N: Ch·ªçn 1 √¥ ƒë·ªÉ l·∫≠t (Kh√¥ng d√πng ƒë∆∞·ª£c M√°y D√≤)",
                    adrenalineDetector: "H∆ØNG PH·∫§N (qua M√°y D√≤): Ch·ªçn √¥ ƒë·ªÉ l·∫≠t. ƒê∆∞·ª£c d√πng M√°y D√≤ (Gi·ªØ B√¨nh Tƒ©nh).",
                    adrenalineDetectorNo: "H∆ØNG PH·∫§N (qua M√°y D√≤): Ch·ªçn √¥ ƒë·ªÉ l·∫≠t (Kh√¥ng d√πng ƒë∆∞·ª£c M√°y D√≤).",
                    deadEnd: " ƒê·∫øm ng∆∞·ª£c v·ªÅ 0: {bombs} Bomb cu·ªëi t·ª± ph√°t n·ªï!Do s·ªë √¥ c√≤n l·∫°i b·∫±ng s·ªë bom!",
                    gameIsOver: "Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c",
                    tileAlreadyFlipped: "√î ƒë√£ ƒë∆∞·ª£c l·∫≠t",
                    tileAlreadyDetected: "√î ƒë√£ ƒë∆∞·ª£c d√≤",
                    noDetectors: "H·∫øt m√°y d√≤",
                    actionFailed: "H√†nh ƒë·ªông th·∫•t b·∫°i"
                },
                tiles: {
                    [TILE_TYPES.BOMB]: ' Bom',
                    [TILE_TYPES.DEFUSE_KIT]: ' B·ªô G·ª°',
                    [TILE_TYPES.DETECTOR_REPAIR]: ' S·ª≠a M√°y D√≤',
                    [TILE_TYPES.EFFECT_SHUFFLE]: ' Rung Ch·∫•n',
                    [TILE_TYPES.EFFECT_ADRENALINE]: 'H∆∞ng Ph·∫•n',
                    [TILE_TYPES.EMPTY]: ' Tr·ªëng'
                }
            }
        };

        const EVENTS = {
            CLASSIC: { 
                id: 'CLASSIC',
                name: 'Classic Event', 
                name_vi: 'C·ªï ƒêi·ªÉn',
                desc: 'No rule changes. Default difficulty baseline.', 
                desc_vi: 'Kh√¥ng c√≥ thay ƒë·ªïi lu·∫≠t ch∆°i. ƒê·ªô kh√≥ m·∫∑c ƒë·ªãnh.',
                difficulty: 'Hard', 
                difficulty_vi: 'Kh√≥',
                modifiers: {}, 
                tooltip: 'No special abilities or modifiers',
                tooltip_vi: 'Kh√¥ng c√≥ g√¨ thay ƒë·ªïi' 
            },
            BONUS_DETECTORS: { 
                id: 'BONUS_DETECTORS',
                name: 'Bonus From Boss', 
                name_vi: 'Qu√† C·ªßa S·∫øp',
                desc: 'One extra Mine Detector at the start.', 
                desc_vi: 'Th√™m 1 m√°y d√≤ khi b·∫Øt ƒë·∫ßu',
                difficulty: 'Normal', 
                difficulty_vi: 'V·ª´a',
                modifiers: { startDetectors: 3 }, 
                tooltip: 'Begin with 3 detectors',
                tooltip_vi: 'Th√™m 1 m√°y d√≤ khi b·∫Øt ƒë·∫ßu'
            },
            LUCKY_FIND: { 
                id: 'LUCKY_FIND',
                name: 'Lucky Find', 
                name_vi: 'V·∫≠n May',
                desc: 'Start with 1 Defuse Kit outside the tile pool.', 
                desc_vi: 'B·∫Øt ƒë·∫ßu v·ªõi 1 B·ªô G·ª° c√≥ s·∫µn.',
                difficulty: 'Easy', 
                difficulty_vi: 'D·ªÖ',
                modifiers: { startExtraDefuse: 1 }, 
                tooltip: 'Gain 1 free defuse kit before game starts',
                tooltip_vi: 'C√≥ s·∫µn 1 b·ªô g·ª° tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu'
            },
            SUDDEN_RAIN: { 
                id: 'SUDDEN_RAIN',
                name: 'Sudden Rain', 
                name_vi: 'M∆∞a B·∫•t Ch·ª£t',
                desc: 'When a Bomb is flipped without a Defuse Kit, that player is eliminated (only once per game). Second bomb without kit = LOSE.', 
                desc_vi: 'L·∫≠t tr√∫ng Bom kh√¥ng c√≥ B·ªô G·ª° l·∫ßn ƒë·∫ßu = B·ªã lo·∫°i (ti·∫øp t·ª•c). L·∫ßn 2 = THUA.',
                difficulty: 'Normal', 
                difficulty_vi: 'V·ª´a',
                modifiers: { suddenRain: true }, 
                tooltip: 'Flip bomb without kit once ‚Üí eliminate & continue. Twice ‚Üí LOSE',
                tooltip_vi: 'L·∫≠t bom kh√¥ng c√≥ b·ªô g·ª° l·∫ßn 1 -> ti·∫øp t·ª•c. L·∫ßn 2 -> THUA'
            },
            CALM_TEAM: { 
                id: 'CALM_TEAM',
                name: 'The Calm Team', 
                name_vi: 'Gi·ªØ B√¨nh Tƒ©nh',
                desc: 'When Adrenaline triggers, you MAY use a Mine Detector before the forced extra flip.', 
                desc_vi: 'Khi H∆∞ng Ph·∫•n k√≠ch ho·∫°t, b·∫°n ƒê∆Ø·ª¢C d√πng M√°y D√≤ tr∆∞·ªõc khi l·∫≠t.',
                difficulty: 'Easy', 
                difficulty_vi: 'D·ªÖ',
                modifiers: { calmTeam: true }, 
                tooltip: 'Use detector during adrenaline flip sequences',
                tooltip_vi: 'D√πng m√°y d√≤ trong l√∫c H∆∞ng Ph·∫•n'
            },
            GOOD_PLACE: { 
                id: 'GOOD_PLACE',
                name: 'A Good Place', 
                name_vi: 'N·ªÅn ƒê·∫•t T·ªët',
                desc: 'Only 1 Shuffle tile exists. Flipping it has NO EFFECT (treated as Empty).', 
                desc_vi: 'Ch·ªâ c√≥ 1 √¥ Rung Ch·∫•n. L·∫≠t n√≥ KH√îNG C√ì T√ÅC D·ª§NG (coi nh∆∞ Tr·ªëng).',
                difficulty: 'Normal', 
                difficulty_vi: 'V·ª´a',
                modifiers: { goodPlace: true }, 
                tooltip: 'Only 1 shuffle in game, it does nothing',
                tooltip_vi: 'Ch·ªâ 1 √¥ Rung Ch·∫•n, kh√¥ng c√≥ t√°c d·ª•ng g√¨'
            }
        };

        // ========================================
        // GAME STATE
        // ========================================
        class GameState {
            constructor(mode, bombCount, event) {
                this.mode = mode; // 'solo' or 'multi'
                this.bombCount = bombCount;
                this.event = event;
                this.tiles = [];
                this.flippedTiles = new Set();
                this.detectedTiles = new Set();
                this.bombsRemaining = bombCount;
                this.detectorsAvailable = 2;
                this.detectorsUsed = 0;
                this.defuseKitsAvailable = 0;
                this.suddenRainUsed = false;
                this.gameOver = false;
                this.gameWon = false;
                this.detectorMode = false;
                this.log = [];
            }

            init() {
                // --- FIX START ---
                // If mode is Solo, force bomb count to 1, regardless of input settings
                if (this.mode === 'solo') {
                    this.bombCount = 1;
                }
                // --- FIX END ---

                this.tiles = [];
                this.flippedTiles = new Set();
                this.detectedTiles = new Set();
                this.gameOver = false;
                this.gameWon = false;
                this.detectorMode = false;
                this.log = [];
                
                this.bombsRemaining = this.bombCount; // Now this will correctly be 1
                this.detectorsUsed = 0;
                this.suddenRainUsed = false;

                // ... rest of the function remains the same
                this.bombsRemaining = this.bombCount;
                this.detectorsUsed = 0;
                this.suddenRainUsed = false;

                // Apply event modifiers
                this.detectorsAvailable = 2;
                this.defuseKitsAvailable = 0;

                // In multi bomb mode, start detectors = bombCount * 2
                if (this.mode === 'multi') {
                    this.detectorsAvailable = this.bombCount * 2;
                }

                if (this.event.modifiers.startDetectors) {
                    this.detectorsAvailable = this.event.modifiers.startDetectors;
                }
                if (this.event.modifiers.startExtraDefuse) {
                    this.defuseKitsAvailable = this.event.modifiers.startExtraDefuse;
                }

                // Build tile pool based on mode
                if (this.mode === 'solo') {
                    this.buildSoloTiles();
                } else {
                    this.buildMultiTiles();
                }

                this.shuffleArray(this.tiles);
            }

            buildSoloTiles() {
                const tileSetup = [
                    { type: TILE_TYPES.BOMB, count: 1 },
                    { type: TILE_TYPES.DEFUSE_KIT, count: 2 },
                    { type: TILE_TYPES.DETECTOR_REPAIR, count: 1 },
                    { type: TILE_TYPES.EFFECT_SHUFFLE, count: 1 },
                    { type: TILE_TYPES.EFFECT_ADRENALINE, count: 1 },
                    { type: TILE_TYPES.EMPTY, count: 2 }
                ];

                for (let setup of tileSetup) {
                    for (let i = 0; i < setup.count; i++) {
                        this.tiles.push({ type: setup.type });
                    }
                }
            }

            buildMultiTiles() {
                const X = this.bombCount;
                let tileSetup = [
                    { type: TILE_TYPES.BOMB, count: X },
                    { type: TILE_TYPES.DEFUSE_KIT, count: X * 2 },
                    { type: TILE_TYPES.DETECTOR_REPAIR, count: X },
                    { type: TILE_TYPES.EFFECT_SHUFFLE, count: 1 },
                    { type: TILE_TYPES.EFFECT_ADRENALINE, count: X },
                    { type: TILE_TYPES.EMPTY, count: X * 2 }
                ];

                for (let setup of tileSetup) {
                    for (let i = 0; i < setup.count; i++) {
                        this.tiles.push({ type: setup.type });
                    }
                }
            }

            shuffleArray(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
            }

            getTile(index) {
                return this.tiles[index] || null;
            }

            isTileFlipped(index) {
                return this.flippedTiles.has(index);
            }

            isDetected(index) {
                return this.detectedTiles.has(index);
            }

            getUnflippedTiles() {
    // Ch·ªâ lo·∫°i tr·ª´ nh·ªØng √¥ ƒë√£ l·∫≠t ho√†n to√†n (isTileFlipped)
    // Gi·ªØ l·∫°i c·∫£ nh·ªØng √¥ ƒë√£ b·ªã soi (detected) nh∆∞ng v·∫´n ƒëang √∫p
    return Array.from({ length: this.tiles.length }, (_, i) => i)
                .filter(i => !this.isTileFlipped(i));
}

            checkDeadEnd() {
                const unflippedCount = this.getUnflippedTiles().length;
                
                // If remaining tiles == bombs remaining, auto-lose
                if (unflippedCount === this.bombsRemaining && this.bombsRemaining > 0) {
                    this.gameOver = true;
                    const msg = TRANSLATIONS[currentLanguage].logs.deadEnd
                        .replace('{unflipped}', unflippedCount)
                        .replace('{bombs}', this.bombsRemaining);
                    this.addLog(msg, 'danger');
                    return true;
                }
                
                return false;
            }

            addLog(message, type = 'info') {
                this.log.push({ message, type, timestamp: Date.now() });
            }
        }

        // ========================================
        // GAME ENGINE
        // ========================================
        class GameEngine {
            constructor() {
                this.state = null;
            }

            init(mode, bombCount, event) {
                this.state = new GameState(mode, bombCount, event);
                this.state.init();
            }

            detectTile(index) {
                if (this.state.gameOver) return { success: false, message: TRANSLATIONS[currentLanguage].logs.gameIsOver };
                if (this.state.isTileFlipped(index)) return { success: false, message: TRANSLATIONS[currentLanguage].logs.tileAlreadyFlipped };
                if (this.state.isDetected(index)) return { success: false, message: TRANSLATIONS[currentLanguage].logs.tileAlreadyDetected };
                if (this.state.detectorsAvailable <= 0) return { success: false, message: TRANSLATIONS[currentLanguage].logs.noDetectors };

                const tile = this.state.getTile(index);
                this.state.detectorsAvailable--;
                this.state.detectorsUsed++;
                this.state.detectedTiles.add(index);

                const tileContent = this.getTileDisplayName(tile.type);
                this.state.addLog(TRANSLATIONS[currentLanguage].logs.detectorUsed.replace('{tile}', tileContent), 'info');

                if (tile.type === TILE_TYPES.BOMB) {
                    if (this.state.defuseKitsAvailable >= 2) {
                        // Defuse successful
                        this.state.defuseKitsAvailable -= 2;
                        this.state.bombsRemaining--;
                        this.state.flippedTiles.add(index);
                        this.state.addLog(TRANSLATIONS[currentLanguage].logs.bombDefused.replace('{count}', this.state.bombsRemaining), 'success');
                        
                        if (this.state.bombsRemaining === 0) {
                            this.state.gameWon = true;
                            this.state.gameOver = true;
                            this.state.addLog(TRANSLATIONS[currentLanguage].logs.allDefused, 'success');
                        } else {
                            // Check dead-end after detector defuse
                            if (this.state.checkDeadEnd()) {
                                return { success: true, tileType: tile.type, bomb: true, defused: true, gameEnded: true };
                            }
                        }
                        
                        return { success: true, tileType: tile.type, bomb: true, defused: true, gameEnded: this.state.gameOver };
                    } else {
                        // Not enough kits - tile stays face-down via detector
                        this.state.addLog(TRANSLATIONS[currentLanguage].logs.bombDetectedNeedKits, 'warning');
                        return { success: true, tileType: tile.type, bomb: true, defused: false, noAction: true };
                    }
                }

                // Not a bomb - flip it and process effect
                this.state.flippedTiles.add(index);
                const flipResult = this.processTileEffect(tile);
                
                // Check dead-end after detector flip
                if (this.state.checkDeadEnd()) {
                    return { success: true, tileType: tile.type, effect: flipResult.effect, gameEnded: true };
                }
                
                return { success: true, tileType: tile.type, effect: flipResult.effect };
            }

            flipTile(index) {
                if (this.state.gameOver) return { success: false, message: TRANSLATIONS[currentLanguage].logs.gameIsOver };
                if (this.state.isTileFlipped(index)) return { success: false, message: TRANSLATIONS[currentLanguage].logs.tileAlreadyFlipped };

                this.state.flippedTiles.add(index);
                const tile = this.state.getTile(index);
                const tileContent = this.getTileDisplayName(tile.type);

                this.state.addLog(TRANSLATIONS[currentLanguage].logs.tileFlipped.replace('{tile}', tileContent), 'success');

                if (tile.type === TILE_TYPES.BOMB) {
                    if (this.state.defuseKitsAvailable >= 2) {
                        // Defuse successful
                        this.state.defuseKitsAvailable -= 2;
                        this.state.bombsRemaining--;
                        this.state.addLog(TRANSLATIONS[currentLanguage].logs.bombDefused.replace('{count}', this.state.bombsRemaining), 'success');
                        
                        // Check if all bombs defused
                        if (this.state.bombsRemaining === 0) {
                            this.state.gameWon = true;
                            this.state.gameOver = true;
                            this.state.addLog(TRANSLATIONS[currentLanguage].logs.allDefused, 'success');
                        }
                        
                        return { success: true, bomb: true, defused: true, gameEnded: this.state.gameOver };
                    } else {
                        // Not enough kits
                        if (this.state.event.modifiers.suddenRain && !this.state.suddenRainUsed) {
                            // Sudden rain saves once
                            this.state.suddenRainUsed = true;
                            this.state.bombsRemaining--;
                            this.state.addLog(TRANSLATIONS[currentLanguage].logs.suddenRainElim, 'danger');
                            
                            if (this.state.bombsRemaining === 0) {
                                this.state.gameWon = true;
                                this.state.gameOver = true;
                                this.state.addLog(TRANSLATIONS[currentLanguage].logs.allDefused, 'success');
                            }
                            
                            return { success: true, bomb: true, defused: false, suddenRain: true, gameEnded: this.state.gameOver };
                        } else {
                            // Game over - bomb hit without kits
                            this.state.gameOver = true;
                            this.state.addLog(TRANSLATIONS[currentLanguage].logs.gameOverBomb, 'danger');
                            return { success: true, bomb: true, defused: false, gameEnded: true };
                        }
                    }
                }

                // Not a bomb - process tile effect
                const flipResult = this.processTileEffect(tile);
                return { success: true, bomb: false, effect: flipResult.effect };
            }

            processTileEffect(tile) {
                if (tile.type === TILE_TYPES.DEFUSE_KIT) {
                    this.state.defuseKitsAvailable++;
                    this.state.addLog(TRANSLATIONS[currentLanguage].logs.defuseKitCollected.replace('{count}', this.state.defuseKitsAvailable), 'success');
                    return { effect: null };
                }

                if (tile.type === TILE_TYPES.DETECTOR_REPAIR) {
                    if (this.state.detectorsUsed > 0) {
                        this.state.detectorsUsed--;
                        this.state.detectorsAvailable++;
                        this.state.addLog(TRANSLATIONS[currentLanguage].logs.detectorRestored.replace('{count}', this.state.detectorsAvailable), 'success');
                    } else {
                        this.state.addLog(TRANSLATIONS[currentLanguage].logs.detectorNoRepair, 'info');
                    }
                    return { effect: null };
                }

                if (tile.type === TILE_TYPES.EFFECT_SHUFFLE) {
                    if (this.state.event.modifiers.goodPlace) {
                        this.state.addLog(TRANSLATIONS[currentLanguage].logs.shuffleNegated, 'info');
                    } else {
                        this.state.addLog(TRANSLATIONS[currentLanguage].logs.shuffleTriggered, 'info');
                        this.shuffleRemaining();
                    }
                    return { effect: { type: 'SHUFFLE' } };
                }

                if (tile.type === TILE_TYPES.EFFECT_ADRENALINE) {
                    this.state.addLog(TRANSLATIONS[currentLanguage].logs.adrenalineTriggered, 'info');
                    return { effect: { type: 'ADRENALINE' } };
                }

                if (tile.type === TILE_TYPES.EMPTY) {
                    this.state.addLog(TRANSLATIONS[currentLanguage].logs.emptyTile, 'info');
                    return { effect: null };
                }

                return { effect: null };
            }

            shuffleRemaining() {
     const unflipped = this.state.getUnflippedTiles(); // L√∫c n√†y ƒë√£ bao g·ªìm th·∫ª bomb ƒë√£ d√≤
    const values = unflipped.map(i => this.state.tiles[i]);
    
    this.state.shuffleArray(values);
    
    unflipped.forEach((idx, pos) => {
        this.state.tiles[idx] = values[pos];
    });

    // QUAN TR·ªåNG: Sau khi x√°o tr·ªôn, v·ªã tr√≠ ƒë√£ soi kh√¥ng c√≤n ch√≠nh x√°c n·ªØa
    // Ch√∫ng ta c·∫ßn x√≥a b·ªô nh·ªõ c√°c √¥ ƒë√£ soi ƒë·ªÉ ng∆∞·ªùi ch∆°i ph·∫£i soi l·∫°i
    this.state.detectedTiles.clear(); 
}

            handleAdrenalineRush() {
                const unflipped = this.state.getUnflippedTiles();
                if (unflipped.length === 0) return { success: false };
                
                const randomIdx = unflipped[Math.floor(Math.random() * unflipped.length)];
                this.state.addLog(TRANSLATIONS[currentLanguage].logs.autoFlip.replace('{index}', randomIdx), 'info');
                return { success: true, autoFlipIndex: randomIdx };
            }

            getTileDisplayName(type) {
                return TRANSLATIONS[currentLanguage].tiles[type] || 'Unknown';
            }
        }
        // ... (existing initialization code) ...

        // Game Over Modal Buttons
        const gameOverModal = document.getElementById('gameOverModal');
        
        document.getElementById('modalRestartBtn').addEventListener('click', () => {
            gameOverModal.classList.remove('show');
            ui.startGame(); // Restart immediately with same settings
        });

        document.getElementById('modalMenuBtn').addEventListener('click', () => {
            gameOverModal.classList.remove('show');
            ui.backToSetup(); // Go back to setup screen
        });

        // ========================================
        // UI CONTROLLER
        // ========================================
        class UIController {
            constructor() {
                this.engine = new GameEngine();
                this.currentMode = 'solo';
                this.currentBombCount = 2;
                this.currentEvent = EVENTS.CLASSIC;
                this.pendingAdrenalineFlip = false;
            }

            initSetupScreen() {
                this.setupLanguageButtons();
                this.setupModeButtons();
                this.setupEventButtons();
                this.updateMultiBombSection();
                this.updateUIText();
            }

            setupLanguageButtons() {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentLanguage = btn.dataset.lang;
                        this.updateUIText();
                        this.setupEventButtons();
                        this.render();
                    });
                });
            }

            updateUIText() {
                const t = TRANSLATIONS[currentLanguage].ui;
                document.querySelector('h1').textContent = t.title;
                document.getElementById('howToPlayBtn').textContent = t.howToPlay;
                document.querySelectorAll('.setup-label')[0].textContent = t.selectMode;
                
                // Update mode buttons text (keep structure)
                const modeBtns = document.querySelectorAll('.mode-btn');
                modeBtns[0].textContent = t.solo;
                modeBtns[1].textContent = t.multi;

                document.querySelectorAll('.setup-label')[1].textContent = t.numBombs;
                
                // FIXED: Use correct selector for hint text
                const hintText = document.querySelector('.hint-text') || document.querySelector('.bomb-count-selector span');
                if (hintText) hintText.textContent = t.autoCalc;
                
                document.querySelectorAll('.setup-label')[2].textContent = t.selectEvent;
                document.getElementById('startBtn').textContent = t.start;

                // FIXED: Use correct selector for board title
                const boardTitle = document.querySelector('.game-section-title') || document.querySelector('.board-section h2');
                if (boardTitle) boardTitle.textContent = t.board;
                
                document.getElementById('btnDetector').textContent = t.useDetector;
                document.getElementById('btnRestart').textContent = t.backToSetup;
                
                // FIXED: Use .info-label instead of .stat-box h3
                const infoLabels = document.querySelectorAll('.info-label');
                if (infoLabels.length >= 5) {
                    infoLabels[0].textContent = t.gameMode;
                    infoLabels[1].textContent = t.bombsRemaining;
                    infoLabels[2].textContent = t.defuseKits;
                    infoLabels[3].textContent = t.detectors;
                    infoLabels[4].textContent = t.status;
                }
                
                const logTitle = document.querySelector('.log-title');
                if (logTitle) logTitle.textContent = t.logTitle;
                
                // Modal
                document.querySelector('#howToPlayModal h2').textContent = t.modalTitle;
                const modalBody = document.getElementById('modalBody');
                if (modalBody) modalBody.innerHTML = t.modalContent;
            }

            setupModeButtons() {
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentMode = btn.dataset.mode;
                        this.updateMultiBombSection();
                    });
                });
            }

            updateMultiBombSection() {
                const section = document.getElementById('multiBombSetup');
                if (this.currentMode === 'multi') {
                    section.style.display = 'block';
                } else {
                    section.style.display = 'none';
                }

                document.getElementById('bombCount').addEventListener('change', (e) => {
                    this.currentBombCount = Math.max(2, Math.min(10, parseInt(e.target.value) || 2));
                    e.target.value = this.currentBombCount;
                });
            }

            setupEventButtons() {
                const grid = document.getElementById('eventsGrid');
                grid.innerHTML = '';

                Object.values(EVENTS).forEach(event => {
                    const btn = document.createElement('button');
                    btn.className = 'event-btn';
                    
                    const name = currentLanguage === 'VI' ? event.name_vi : event.name;
                    const diff = currentLanguage === 'VI' ? event.difficulty_vi : event.difficulty;
                    const tooltip = currentLanguage === 'VI' ? event.tooltip_vi : event.tooltip;

                    btn.setAttribute('data-tooltip', tooltip);
                    btn.innerHTML = `<strong>${name}</strong><div class="event-difficulty">${diff}</div>`;
                    btn.title = tooltip;
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.event-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentEvent = event;
                    });

                    if (event === this.currentEvent || (this.currentEvent === EVENTS.CLASSIC && event === EVENTS.CLASSIC)) {
                        btn.classList.add('active');
                        // Ensure currentEvent is updated to match ref (useful on language switch if object ref matters, though here we use same objects)
                        this.currentEvent = event;
                    }

                    grid.appendChild(btn);
                });
            }

            startGame() {
                this.engine.init(this.currentMode, this.currentBombCount, this.currentEvent);
                document.getElementById('setupScreen').style.display = 'none';
                document.getElementById('gameScreen').style.display = 'block';
                this.render();
                this.attachGameEventListeners();
            }

            attachGameEventListeners() {
                const detectorBtn = document.getElementById('btnDetector');
                const restartBtn = document.getElementById('btnRestart');
                
                // Remove old listeners
                const newDetectorBtn = detectorBtn.cloneNode(true);
                const newRestartBtn = restartBtn.cloneNode(true);
                detectorBtn.parentNode.replaceChild(newDetectorBtn, detectorBtn);
                restartBtn.parentNode.replaceChild(newRestartBtn, restartBtn);
                
                document.getElementById('btnDetector').addEventListener('click', () => this.toggleDetectorMode());
                document.getElementById('btnRestart').addEventListener('click', () => this.backToSetup());

                const board = document.getElementById('board');
                const newBoard = board.cloneNode(true);
                board.parentNode.replaceChild(newBoard, board);
                
                document.getElementById('board').addEventListener('click', (e) => {
                    if (e.target.classList.contains('tile')) {
                        const index = parseInt(e.target.dataset.index);
                        this.handleTileClick(index);
                    }
                });
            }

            toggleDetectorMode() {
                if (this.engine.state.gameOver) {
                    alert(TRANSLATIONS[currentLanguage].logs.gameIsOver);
                    return;
                }
                // Detectors disabled during adrenaline flip (unless CALM TEAM event)
                if (this.pendingAdrenalineFlip && !this.engine.state.event.modifiers.calmTeam) {
                    alert(TRANSLATIONS[currentLanguage].logs.adrenalineChoice);
                    return;
                }
                if (this.engine.state.detectorsAvailable <= 0) {
                    alert(TRANSLATIONS[currentLanguage].logs.noDetectors);
                    return;
                }
                this.engine.state.detectorMode = !this.engine.state.detectorMode;
                this.updateDetectorButton();
                this.render();
            }

            // Trong class UIController
handleTileClick(index) {
    if (this.engine.state.gameOver) {
        alert(TRANSLATIONS[currentLanguage].logs.gameIsOver);
        return;
    }
    
    // N·∫øu √¥ ƒë√£ l·∫≠t h·∫≥n r·ªìi th√¨ b·ªè qua
    if (this.engine.state.isTileFlipped(index)) return;

    // L·∫•y th√¥ng tin √¥
    const isDetected = this.engine.state.isDetected(index);
    const tile = this.engine.state.getTile(index);

    // --- S·ª¨A LOGIC CH·∫∂N CLICK ---
    // Ch·ªâ ch·∫∑n click n·∫øu:
    // 1. √î ƒë√£ ƒë∆∞·ª£c d√≤ 
    // 2. V√Ä √¥ ƒë√≥ KH√îNG PH·∫¢I L√Ä BOM (v√¨ bom ƒë√£ d√≤ v·∫´n c·∫ßn click ƒë·ªÉ g·ª°)
    // 3. V√Ä kh√¥ng ph·∫£i ƒëang trong ch·∫ø ƒë·ªô Adrenaline (Adrenaline ƒë∆∞·ª£c click t·∫•t)
    if (isDetected && tile.type !== TILE_TYPES.BOMB && !this.pendingAdrenalineFlip) {
        return; 
    }
    // ----------------------------

    // N·∫øu ƒëang ch·ªù Adrenaline
    if (this.pendingAdrenalineFlip) {
        this.completeAdrenalineFlip(index);
        return;
    }

    if (this.engine.state.detectorMode) {
        this.handleDetectorClick(index);
    } else {
        // L√∫c n√†y click v√†o Bom ƒë√£ d√≤ s·∫Ω ch·∫°y xu·ªëng ƒë√¢y ƒë·ªÉ g·ª°
        this.handleFlipClick(index);
    }
}

            handleDetectorClick(index) {
                const result = this.engine.detectTile(index);
                if (!result.success) {
                    alert(result.message);
                    return;
                }

                // Check for dead-end FIRST (before adrenaline effect)
                if (this.engine.state.checkDeadEnd()) {
                    this.engine.state.gameOver = true;
                    this.updateDetectorButton();
                    this.render();
                    return;
                }

                // Bomb detected with enough kits - WIN
                if (result.bomb && result.defused) {
                    if (result.gameEnded) {
                        this.engine.state.gameWon = true;
                        this.engine.state.gameOver = true;
                    }
                    this.updateDetectorButton();
                    this.render();
                    return;
                }

                // Bomb detected but not enough kits
                if (result.bomb && result.noAction) {
                    this.engine.state.detectorMode = false;
                    this.updateDetectorButton();
                    this.render();
                    return;
                }

                // Non-bomb tile detected - check for adrenaline effect AFTER dead-end check
                if (result.effect && result.effect.type === 'ADRENALINE') {
                    this.pendingAdrenalineFlip = true;
                    if (this.engine.state.event.modifiers.calmTeam) {
                        this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.adrenalineDetector, 'warning');
                    } else {
                        this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.adrenalineDetectorNo, 'warning');
                    }
                    this.engine.state.detectorMode = false;
                    this.updateDetectorButton();
                    this.render();
                    return;
                }

                this.engine.state.detectorMode = false;
                this.updateDetectorButton();
                this.render();
            }

            handleFlipClick(index) {
                const result = this.engine.flipTile(index);

                if (!result.success) {
                    alert(result.message || TRANSLATIONS[currentLanguage].logs.actionFailed);
                    return;
                }

                // Check for dead-end FIRST (before adrenaline effect)
                if (this.engine.state.checkDeadEnd()) {
                    this.engine.state.gameOver = true;
                    this.render();
                    return;
                }

                // Handle bomb flip
                if (result.bomb) {
                    if (result.defused) {
                        // Bomb defused successfully
                        if (result.gameEnded) {
                            // All bombs defused - WIN
                            this.engine.state.gameWon = true;
                            this.engine.state.gameOver = true;
                        }
                        this.render();
                        return;
                    } else if (result.suddenRain) {
                        // Sudden rain activated
                        if (result.gameEnded) {
                            // All bombs defeated via sudden rain - WIN or DEAD-END
                            if (this.engine.state.gameWon) {
                                this.engine.state.gameWon = true;
                                this.engine.state.gameOver = true;
                            } else {
                                this.engine.state.gameOver = true;
                            }
                        }
                        this.render();
                        return;
                    } else {
                        // Bomb hit without kits - LOSE
                        this.engine.state.gameOver = true;
                        this.render();
                        return;
                    }
                }

                // Handle adrenaline effect AFTER dead-end check
                if (result.effect && result.effect.type === 'ADRENALINE') {
                    this.pendingAdrenalineFlip = true;
                    this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.adrenalineChoice, 'warning');
                    this.render();
                    return;
                }

                this.render();
            }

            // Trong class UIController
completeAdrenalineFlip(index) {
    const tile = this.engine.state.getTile(index);
    
    // ƒê√°nh d·∫•u ƒë√£ l·∫≠t
    this.engine.state.flippedTiles.add(index);
    
    // Log th√¥ng b√°o
    this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.adrenalineFlipResult.replace('{tile}', this.engine.getTileDisplayName(tile.type)), 'info');

    // T·∫Øt tr·∫°ng th√°i ch·ªù Adrenaline TR∆Ø·ªöC (ƒë·ªÉ render ƒë√∫ng)
    this.pendingAdrenalineFlip = false;

    // TR∆Ø·ªúNG H·ª¢P 1: L·∫¨T TR√öNG BOM
    if (tile.type === TILE_TYPES.BOMB) {
        if (this.engine.state.defuseKitsAvailable >= 2) {
            this.engine.state.defuseKitsAvailable -= 2;
            this.engine.state.bombsRemaining--;
            
            if (this.engine.state.bombsRemaining === 0) {
                this.engine.state.gameWon = true;
                this.engine.state.gameOver = true;
                this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.allDefused, 'success');
            } else {
                this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.bombDefusedAdrenaline.replace('{count}', this.engine.state.bombsRemaining), 'success');
                
                // Ki·ªÉm tra Dead-end sau khi g·ª° bom (tr∆∞·ªùng h·ª£p hi·∫øm nh∆∞ng c·∫ßn thi·∫øt)
                if (this.engine.state.checkDeadEnd()) {
                     this.engine.state.gameOver = true;
                }
            }
        } else {
            // X·ª≠ l√Ω M∆∞a B·∫•t Ch·ª£t ho·∫∑c Thua
            if (this.engine.state.event.modifiers.suddenRain && !this.engine.state.suddenRainUsed) {
                this.engine.state.suddenRainUsed = true;
                this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.suddenRainElim, 'danger');
                this.engine.state.bombsRemaining--;
                
                if (this.engine.state.bombsRemaining === 0) {
                    this.engine.state.gameWon = true;
                    this.engine.state.gameOver = true;
                    this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.allDefused, 'success');
                } else {
                    // Check dead-end sau khi bom bi·∫øn m·∫•t do m∆∞a
                    if (this.engine.state.checkDeadEnd()) {
                        this.engine.state.gameOver = true;
                    }
                }
            } else {
                this.engine.state.gameOver = true;
                this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.gameOverAdrenaline, 'danger');
            }
        }
    } 
    // TR∆Ø·ªúNG H·ª¢P 2: L·∫¨T √î AN TO√ÄN (KH√îNG PH·∫¢I BOM)
    else {
        const flipResult = this.engine.processTileEffect(tile);
        
        // --- S·ª¨A QUAN TR·ªåNG: KI·ªÇM TRA DEAD-END NGAY T·∫†I ƒê√ÇY ---
        // Sau khi l·∫≠t 1 √¥ th∆∞·ªùng, ki·ªÉm tra xem s·ªë √¥ √∫p c√≤n l·∫°i c√≥ b·∫±ng s·ªë bom kh√¥ng
        if (this.engine.state.checkDeadEnd()) {
            this.engine.state.gameOver = true;
            // Kh√¥ng return ·ªü ƒë√¢y ƒë·ªÉ code render ch·∫°y ·ªü d∆∞·ªõi
        } 
        // N·∫øu ch∆∞a Dead-end th√¨ m·ªõi x√©t ti·∫øp hi·ªáu ·ª©ng Adrenaline n·ªëi ti·∫øp
        else if (flipResult.effect && flipResult.effect.type === 'ADRENALINE') {
            this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.adrenalineAgain, 'warning');
            this.pendingAdrenalineFlip = true;
        }
        // -------------------------------------------------------
    }

    this.render();
}

            handleAutoFlip(index) {
                const tile = this.engine.state.getTile(index);
                this.engine.state.flippedTiles.add(index);
                this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.autoFlipResult.replace('{tile}', this.engine.getTileDisplayName(tile.type)), 'info');

                if (tile.type === TILE_TYPES.BOMB) {
                    if (this.engine.state.defuseKitsAvailable >= 2) {
                        this.engine.state.defuseKitsAvailable -= 2;
                        this.engine.state.bombsRemaining--;
                        this.engine.state.gameWon = this.engine.state.bombsRemaining === 0;
                        this.engine.state.gameOver = this.engine.state.gameWon;
                        if (this.engine.state.gameWon) {
                            this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.bombDefusedAuto.replace('{count}', this.engine.state.bombsRemaining), 'success');
                        }
                        if (this.engine.state.gameOver) {
                            this.render();
                            return;
                        }
                    } else {
                        if (this.engine.state.event.modifiers.suddenRain && !this.engine.state.suddenRainUsed) {
                            this.engine.state.suddenRainUsed = true;
                            this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.suddenRainElim, 'danger');
                            this.engine.state.bombsRemaining--;
                            if (this.engine.state.bombsRemaining === 0) {
                                this.engine.state.gameWon = true;
                                this.engine.state.gameOver = true;
                            }
                        } else {
                            this.engine.state.gameOver = true;
                            this.engine.state.addLog(TRANSLATIONS[currentLanguage].logs.gameOverAuto, 'danger');
                        }
                        this.render();
                        return;
                    }
                } else {
                    const flipResult = this.engine.processTileEffect(tile);
                    if (flipResult.effect && flipResult.effect.type === 'ADRENALINE') {
                        const rush = this.engine.handleAdrenalineRush();
                        if (rush.success) {
                            this.handleAutoFlip(rush.autoFlipIndex);
                            return;
                        }
                    }
                }

                this.render();
            }

            showAdrenalineWithDetector(index) {
                alert('Adrenaline triggered! THE CALM TEAM event allows you to use a detector before the auto-flip. Use detector next turn if needed.');
                this.render();
            }

            backToSetup() {
                document.getElementById('gameScreen').style.display = 'none';
                document.getElementById('setupScreen').style.display = 'block';
                document.getElementById('statusMessage').innerHTML = '';
            }

            render() {
                this.renderBoard();
                this.renderInfo();
                this.renderLog();
                this.updateDetectorButton();

                if (this.engine.state.gameOver) {
                    this.renderGameOverMessage();
                }
            }

            renderBoard() {
                const board = document.getElementById('board');
                board.innerHTML = '';

                // Calculate grid columns based on tile count
                const tileCount = this.engine.state.tiles.length;
                const cols = Math.ceil(Math.sqrt(tileCount));
                board.style.gridTemplateColumns = `repeat(${cols}, 80px)`;

                for (let i = 0; i < tileCount; i++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.index = i;

                    const isFlipped = this.engine.state.isTileFlipped(i);
                    const isDetected = this.engine.state.isDetected(i);

                    if (isFlipped) {
                        const tileData = this.engine.state.getTile(i);
                        tile.textContent = '';
                        tile.classList.add('tile-flipped', this.getTileColorClass(tileData.type));
                        tile.style.pointerEvents = 'none';
                    } if (isDetected) {
        const tileData = this.engine.state.getTile(i);
        
        if (tileData.type === TILE_TYPES.BOMB) {
            // Hi·ªÉn th·ªã icon bom m·ªù ho·∫∑c d·∫•u hi·ªáu c·∫£nh b√°o
            tile.textContent = ''; 
            tile.classList.add('tile-unflipped', 'tile-disabled');
            
            // --- S·ª¨A T·∫†I ƒê√ÇY: LU√îN CHO PH√âP CLICK V√ÄO BOM ƒê√É D√í ---
            // D√π c√≥ adrenaline hay kh√¥ng, √¥ bom ƒë√£ d√≤ v·∫´n ph·∫£i click ƒë∆∞·ª£c ƒë·ªÉ g·ª°
            tile.style.pointerEvents = 'auto'; 
            tile.style.cursor = 'pointer';
            
            // Th√™m vi·ªÅn ƒë·ªè/cam ƒë·ªÉ ng∆∞·ªùi ch∆°i bi·∫øt ƒë√¢y l√† bom ƒë√£ d√≤
            tile.style.border = '2px dashed var(--danger-ink)'; 
            // -------------------------------------------------------
            
        } else {
            // C√°c √¥ an to√†n ƒë√£ d√≤ th√¨ hi·ªÉn th·ªã n·ªôi dung v√† KH√ìA l·∫°i
            tile.textContent = '';
            tile.classList.add('tile-flipped', this.getTileColorClass(tileData.type));
            tile.style.pointerEvents = 'none'; // Kh√≥a click
            tile.style.fontSize = '24px';
            tile.style.textShadow = '0 0 5px #000';
        }
    } else {
                        tile.classList.add('tile-unflipped');
                        tile.textContent = this.pendingAdrenalineFlip ? '‚ö°' : '';
                        tile.classList.add('tile-disabled');
                        // During adrenaline, tiles are clickable to select
                        if (this.pendingAdrenalineFlip) {
                            tile.classList.remove('tile-disabled');
                            tile.style.pointerEvents = 'auto';
                            tile.style.borderColor = '#7a7aff';
                            tile.style.filter = 'brightness(1.3)';
                        } else if (this.engine.state.gameOver) {
                            tile.style.pointerEvents = 'none';
                        }
                    }

                    if (this.engine.state.detectorMode && !isFlipped && !isDetected && !this.pendingAdrenalineFlip) {
                        tile.classList.add('detector-mode-active');
                    }

                    board.appendChild(tile);
                }
            }

            renderInfo() {
                const t = TRANSLATIONS[currentLanguage].ui;
                const mode = this.engine.state.mode === 'solo' ? t.solo : `${t.multi} (${this.engine.state.bombCount})`;
                document.getElementById('gameMode').textContent = mode;
                document.getElementById('bombsRemaining').textContent = this.engine.state.bombsRemaining;
                document.getElementById('defuseKitsAvailable').textContent = this.engine.state.defuseKitsAvailable;
                document.getElementById('detectorsAvailable').textContent = this.engine.state.detectorsAvailable;
                
                let status = t.playing;
                if (this.engine.state.gameOver) {
                    status = this.engine.state.gameWon ? t.won : t.lost;
                }
                document.getElementById('gameStatus').textContent = status;

                const eventName = currentLanguage === 'VI' ? this.engine.state.event.name_vi : this.engine.state.event.name;
                const eventDesc = currentLanguage === 'VI' ? this.engine.state.event.desc_vi : this.engine.state.event.desc;

                document.getElementById('eventTitle').textContent = `üìã ${eventName}`;
                document.getElementById('eventDesc').textContent = eventDesc;
            }

            renderLog() {
                const logContent = document.getElementById('logContent');
                logContent.innerHTML = '';

                this.engine.state.log.forEach(entry => {
                    const div = document.createElement('div');
                    div.className = `log-entry ${entry.type}`;
                    div.textContent = entry.message;
                    logContent.appendChild(div);
                });

                logContent.scrollTop = logContent.scrollHeight;
            }
            renderGameOverMessage() {
    const t = TRANSLATIONS[currentLanguage].ui;
    const modal = document.getElementById('gameOverModal');
    const title = document.getElementById('gameOverTitle');
    const msg = document.getElementById('gameOverMessage');
    const restartBtn = document.getElementById('modalRestartBtn');
    const menuBtn = document.getElementById('modalMenuBtn');

    // 1. L·∫•y th√¥ng tin t·ª´ engine
    const state = this.engine.state;
    const logs = state.log;
    // L·∫•y n·ªôi dung tin nh·∫Øn cu·ªëi c√πng trong log (l√Ω do th·∫Øng/thua)
    const lastAction = logs.length > 0 ? logs[logs.length - 1].message : "";

    if (state.gameWon) {
        title.textContent = "‚úØ " + t.gameOverTitleWin + " ‚úØ";
        title.style.color = 'var(--success-ink)';
        title.style.borderColor = 'var(--success-ink)';
        
        // 2. S·ª≠ d·ª•ng innerHTML ƒë·ªÉ hi·ªÉn th·ªã c·∫£ 2 d√≤ng
        msg.innerHTML = `
            <div style="margin-bottom: 10px; font-weight: bold;">${t.winMsg}</div>
            <div style="font-size: 0.9em; color: #555; font-style: italic; border-top: 1px dashed #ccc; padding-top: 5px;">
                "${lastAction}"
            </div>
        `;
    } else {
        title.textContent = "‚ò† " + t.gameOverTitleLose + " ‚ò†";
        title.style.color = 'var(--danger-ink)';
        title.style.borderColor = 'var(--danger-ink)';
        
        msg.innerHTML = `
            <div style="margin-bottom: 10px; font-weight: bold;">${t.loseMsg}</div>
            <div style="font-size: 0.9em; color: #721c24; font-style: italic; border-top: 1px dashed #f5c6cb; padding-top: 5px;">
                "${lastAction}"
            </div>
        `;
    }
    
    // C·∫≠p nh·∫≠t text cho n√∫t b·∫•m
    restartBtn.textContent = "‚ü≥ " + t.btnReplay;
    menuBtn.textContent = "‚åÇ " + t.btnMenu;

    // Hi·ªÉn th·ªã modal
    modal.classList.add('show');
}

            updateDetectorButton() {
                const t = TRANSLATIONS[currentLanguage].ui;
                const btn = document.getElementById('btnDetector');
                const info = document.getElementById('detectorInfo');

                // Disable detector if pending adrenaline (unless CALM TEAM event)
                if (this.pendingAdrenalineFlip && !this.engine.state.event.modifiers.calmTeam) {
                    btn.disabled = true;
                    info.textContent = t.adrenalineMode;
                    return;
                }

                if (this.engine.state.detectorsAvailable <= 0) {
                    btn.disabled = true;
                } else {
                    btn.disabled = false;
                }

                if (this.engine.state.detectorMode) {
                    btn.classList.add('active');
                    info.textContent = `${t.detectorOn} (${this.engine.state.detectorsAvailable})`;
                } else {
                    btn.classList.remove('active');
                    info.textContent = `${t.detectorOff} (${this.engine.state.detectorsAvailable})`;
                }
            }

            getTileDisplay(type) {
                return '';
            }

            getTileColorClass(type) {
                const classes = {
                    [TILE_TYPES.BOMB]: 'tile-bg-bomb',
                    [TILE_TYPES.DEFUSE_KIT]: 'tile-bg-defuse',
                    [TILE_TYPES.DETECTOR_REPAIR]: 'tile-bg-repair',
                    [TILE_TYPES.EFFECT_SHUFFLE]: 'tile-bg-shuffle',
                    [TILE_TYPES.EFFECT_ADRENALINE]: 'tile-bg-adrenaline',
                    [TILE_TYPES.EMPTY]: 'tile-bg-empty'
                };
                return classes[type] || '';
            }
        }

        // ========================================
        // INITIALIZE
        // ========================================
        const ui = new UIController();
        ui.initSetupScreen();

        document.getElementById('startBtn').addEventListener('click', () => {
            ui.startGame();
        });

        // How to Play Modal
        const modal = document.getElementById('howToPlayModal');
        const howToPlayBtn = document.getElementById('howToPlayBtn');
        const closeModalBtn = document.getElementById('closeModalBtn');

        howToPlayBtn.addEventListener('click', () => {
            modal.classList.add('show');
        });

        closeModalBtn.addEventListener('click', () => {
            modal.classList.remove('show');
        });

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.remove('show');
            }
        });
    </script>
</body>
</html>
